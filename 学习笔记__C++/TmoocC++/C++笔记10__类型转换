类型转换

类型转换是一个表达式，生成一个类型。如 
	* C风格：int i=0x12345678  char c=(char)i;
	* C++风格的类型转换，char c=char (i);
	* 风险。显示类型转换，意味着我就是要这样转，但是不能完全排除bug。如截断、扩展符号位。
静态类型转换：
	* static_cast<目标转换>(源转换) cast为铸造的意思。它要求“目标转换”类型可以隐式的转换成“源转换”。
		例如：	
		int main(void)
		{
			int* pi;
			void* pv=pi;	//任何指针类型都可以转换转void*。
			pi = static_case<int*>(pv);
		}
		- 将泛型转换成具体的类型。如：
		例如：int compare(const void* a, const void* b){}
	* 动态类型转换
		- 

	* 常类型转换
		- const_cast<目标转换类型>(源类型) 
		- 去除指针
		- 用于同种类型的转换，去除const。
		- 可以取出引用的const。去除常引用。
		如：
			const int* p1;
			int*p2;
			p2 = p1;	//此处会报错。但是如果我知道风险，我就是要这么转换。
					那么就可以用const_cast<>();
		如：
			const int c=100；//此处的c变量是变量名，是不能改变的。但是这个变量是放在“栈”上的，
					//值是可以修改的。只是不能通过变量名进行修改。可以试着用指针修改。
			int* pc = &c;	//那么取地址操作符$,C的地址也是有const属性的。这里相当于const int*
					//转换成了int*，是不能隐式转换的。需要用去掉const属性。
			int* pc = const_cast<int*>(&c);
			*pc = 200;	//此时的c是200了么？
					//不是，因为这里编译器进行了“常量优化”。当你打印变量名时，已经
					//被编译器替换成了100，这个常属性值。直接输出了100，防止再从内存
					//中读取变量名的值。
					//可以修改变量名的修饰，添加volatile关键字
			const volatile int c=100；
			int* pc=const_cast<int*>(&c);
			*pc = 200;
			cout << pc <<' '<< (void*)&c << endl;	//这里需要使用(void*)修饰&c；

	

1. 常量优化，使用变量名c还需要访问内存，所以编译器就帮你优化了，直接从代码段去了100这个数据。
   
2. 寄存器优化，除了被代码修改数据，相应的寄存器还可能被外围电路所修改，如一些数据收发，中断状态，等
   所以可以使用volatile进行修饰。告诉编译器不要进行优化。
3. 
	
			
