引用
	- 引用，就是别名。前面的是引用的类型。
		int a = 10;
		int& b = a; //这里的&不是取地址，而是引用的意思。C++中有好多的符号复用，为了方便
		根据环境不同，有不同的意思。
		int& c = b; //那么其实就像诸葛亮 = 孔明 = 卧龙一样，不同的别名。
	- 引用，必须初始化。
		int& b;	//error 有别名，却不不知道是谁的别名。
		int& b = a;
		const int& b = 10 //可以引用常量，但是需要在前面加上一个const。
	- 引用，不能为空。
		相对指针而言的，如指针可以是NULL空指针。
	- 引用不能更换目标
		指针能够跟换目标，但是引用不能。引用是从一而终的。
==========================================================================================
引用的应用场景：
	- 引用型“形参”，在函数中对形参进行引用，当对实参变量操作时,就可以直接用
	引用进行代替实参。进行函数的操作。
		* 在函数中修改实参值。
		* 避免对象复制的开销。如结构体的复制，大数组的复制。
		举例：
	* 思考：打印printf("a is %d\n", a);这里怎么打印的a的值。
		在编译后，没有a这样的变量明，只有指令和地址，所以，printf的其实
		是a的地址。
		所以，swap()；函数，要会复制/拷贝一份变量到函数中。需要找到变量
		的地址，才能进行交换。
		int main()
		{
			int a=3,b=4;
			swap1(a,b);
			swap2(a,b);
			const char*x="hello";
			const char*y="welcome";
		}
		void swap1(int a,int b)
		{
			int c=a;
			b = c;		
			c = a;
		}
	* 如果是字符串呢：在C语言中没有字符串类型，需要用数组或者一维指针。那么
		在swap();函数中需要交换的是指向，一维指针的的指针变量。	
		如果是字符串：
		void swap4(const char*x, const char*y)
		{
			const char*z=x;
			x = y;
			y = z;
		}(错) 
		void swap6(const char*&x ,char*&y)
		{
			const char* z=x;
			x = y;
			y = z;
		}
“常”引用型参数
	* 接受常量型实参
	* 防止对实参的“意外”修改

引用型“返回值” (匿名变量一般是右值)，从函数中返回引用，一定要保证在函数返回以后，
该引用的目标依然有效。
	* 返回左值。（右值不能放在左边。但是C++有条件的允许这样的情况。）
		- 返回变量类型为$引用。
		int& foo(void)
		{ return x;}
		int main(void)
		{
			foo() = 10;
			cout << x << endl;
			++foo(); //因为返回的是引用(左之)，所以可以进行自加操作	
		}
	* 可以返回全局、静态，乃至成员变量的引用
		- 如果返回的是局部变量，那么局部变量，在函数返回后，会被标记为自由的内存地址
		  可以被其他的变量使用。所以返回局部变量的引用时，是不稳定的！
	  int& foo(int& r)
	  {
	  	return r; //因为传的就是引用，实参是存在的。所以返回的是实参的引用，它是
			  //在函数返回后，也存在的。
	  }
	* 可以返回在“堆”中动态创建的对象的引用 (堆中的内存需要自己手动进行释放。)


在实现层面，引用就是指针，但在语言层面，引用不是"实体类型"，他是高级语言为方便抽象而成。
因此与指针存在明显的差别
	* 指针可以不初始化，其目标可在初始化后随意变更(除非是指针变量)，而引用必须初始化，且
	  一旦初始化，就"无法变更"其目标。
	* 存在控制真，不存在空引用
	* 存在指向指针的指针，不存在引用引用的引用(本身引用就不是实体，在内存中没有类型)
	* 可以定义指针型数组，但是不能定义引用型数组。
	* 未记完全
	  


1. 简单的程序的具体执行过程，存在哪里，如何实现的。需要从编译器的角度思考这些问题。
2. 引用可以看做是对变量的地址的定位。
3. 数组名在不同的C语境下，代表的意思也不同。
   可以代表首地址，也可以代表整个数组。
   int arr[]={1,2,3};
   sizeof(arr),它是整个数组的大小；
   &arr，数组名取地址，那么此时的数组名是一个整体。类型是int (*)[3]。
4. 优化，只能优化一些虚的东西。比如动态内存分配，它已经是一层封装了。所以可以进行优化。
   但是，如果是定义了一个很大的数组，是无法进行优化性能的。直接用就行了。速度很快了。   



	
