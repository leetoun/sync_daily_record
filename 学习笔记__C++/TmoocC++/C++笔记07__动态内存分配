动态内存分配：
	- 继续是用标准C的库函数，malloc/calloc/realloc/free
	- 使用new/delete"操作符"在"堆"中分配/释放内存
	  * 举例，		
		int*pi = new int; //new是一个运算符，可以动态分配堆栈
		int*pi = (int*)malloc(sizeof(int)); //等价于上面的语句
		内存用完了，要释放了。用delete。
		delete pi;
		free(pi);
	  * 可以在分配的时候进行，进行初始化。int* pi = new int(100)
	  * 如果使用了多次的delete，那么会出现“核心已转移”的错误也叫“吐核”，
	    进程被回收，并记录此时的程序详细信息map文件。(free同样会崩溃！)
		delete pi;
		delete pi;
	  * 可以多次delete NULL指针。
		delete pi;
		pi = NULL; //如果使用空指针，则delete对指针检查，不会出错。
		delete pi;

	- 分配数组
		pi = new int[4]{1,2,3,4};  //花括号是需要-std=gnu++0x使用C++11的标准。
		或者 使用-std=C++0x。
		cout << p1[0] << ' ' << p1[1] << ' ' << endl;
	  * 如果动态分配的new是数组，那么释放的时候也需要使用delete[]的方式
		int pi = new int[4]{};
		delete[] p1;     
		 __________
		|4|x x x x | 
		 ——————————
		| |
		1 2
		  如果不是基本类型的话，如类类型，数据方式分配了内存。
		前面会存放一个4来存放元素个数，1是实际分配的地址，
		而2是分配返回的我们正常使用的地址。我们使用完后，不能直接用：
			delete pi; //释放了2以后的数据内存。
		进行释放，因为释放的是2开始往后的数据内存，不包括1。
		并且，内存是不能"局部释放"的。所以，需要使用：
			delete[] pi; //完整释放复合类型的数据的内存。

	- 通过new操作符分配的N维数组，返回N-1维数组指针。
		* int(* pa)[4] = int[3][4]; //pa是一个指向 x[4]数组的指针。2维-->1维
		* 如果对int[3][4]进行初始化的话，需要用{}把1维数组体现出来。
			{ {,,,},{,,,},{,,,},{,,,} } //在标准C中，可以直接写数字。

	- 不能通过delete操作符释放已经被释放过的内存。---> 会“吐核”生成map文件。
	
	- dlete野指针后果未定义，delete空指针安全。

	- 内存分配失败，new操作符抛出bad_alloc异常。
		  malloc分配失败，会返回一个空指针。而new会返回bad_alloc。malloc不成功，可以
		提示内存分配失败(没有足够内存！)，但是返回bad_alloc就直接“吐核”了。
		  这里可以使用try 和catch 进行错误的捕获，然后输出类似C的错误提示信息。然后
		退出程序。比较优雅。
	- 定位分配(用的少)
		* new（指针）类型(初值)；
		* 在一个“已分配”的内存空间创建对象；
		char buf[8];
		p1 = new (buf)int (0x12345678); //在buf指的地址上初始化0x12345678
		cout << hex << *p1 << endl;
		cout << buf[0] << ‘ ’ << buf[1] << ....<< endl;




